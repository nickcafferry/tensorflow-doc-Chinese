

<!DOCTYPE html>
<html class="writer-html5" lang="Chinese" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tensorflow.python.ops.check_ops &mdash; tensorflow 0.1.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/GCC.png"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #343131" >
          

          
            <a href="../../../../index.html" class="icon icon-home" alt="Documentation Home"> tensorflow
          

          
            
            <img src="../../../../_static/GCC.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">从TensorFlow开始 (Getting Started)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html">TensorFlow如何工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id1">变量和张量的声明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id2">使用占位符和变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id3">矩阵</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id4">操作符的声明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id5">载入激活函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id6">数据资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id7">资源库</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../01_Introduction/index.html#id8">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">TensorFlow方式 (TensorFlow Way)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html">计算图</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id2">分层嵌套操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id3">多层操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id4">载入损失函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id5">载入反向传播</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id6">随机和批量训练</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id7">结合训练</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id8">模型评估</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../02_TensorFlow_Way/index.html#id9">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">线性回归 (Linear Regression)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html">矩阵转置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#id2">矩阵分解法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#tensorflow">TensorFLow的线性回归</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#id3">线性回归的损失函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#deming">Deming回归(全回归)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#lasso-ridge">套索(Lasso)回归和岭(Ridge)回归</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#elastic-net">弹性网(Elastic Net)回归</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#logistic">逻辑(Logistic)回归</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../03_Linear_Regression/index.html#id4">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">支持向量机(Support Vector Machines)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html">引言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html#id2">线性支持向量机</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html#id3">回归线性回归</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html#tensorflow">TensorFlow中的核</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html#id4">非线性支持向量机</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html#id5">多类支持向量机</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../04_Support_Vector_Machines/index.html#id6">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">最近邻法 (Nearest Neighbor Methods)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html">引言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html#id2">最近邻法的使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html#id3">文本距离函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html#id4">计算混合距离函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html#id5">地址匹配</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html#id6">图像处理的近邻法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../05_Nearest_Neighbor_Methods/index.html#id7">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">神经元网络 (Neural Networks)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html">引言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id2">载入操作门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id3">门运算和激活函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id4">载入一层神经网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id5">载入多层神经网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id6">使用多层神经网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id7">线性模型预测改善</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id8">神经网络学习井字棋</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../06_Neural_Networks/index.html#id9">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">自然语言处理(NLP)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html">引言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#bag-of-words">词袋 (Bag of Words)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#tf-idf">词频-逆文本频率 (TF-IDF)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#skip-gram">运用Skip-Gram</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#cbow-continuous-bag-fo-words">CBOW (Continuous Bag fo Words)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#word2vec">Word2Vec应用实例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#doc2vec-sentiment-analysis">Doc2Vec情感分析 (Sentiment Analysis)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#id2">神经网络学习井字棋</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../07_Natural_Language_Processing/index.html#id3">本章学习模块</a></li>
</ul>
<p class="caption"><span class="caption-text">卷积神经网络(CNN)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../08_Convolutional_Neural_Networks/index.html">引言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../08_Convolutional_Neural_Networks/index.html#simple-cnns">简单卷积神经网络 (Simple CNNs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../08_Convolutional_Neural_Networks/index.html#advanced-cnns">高级卷积神经网络 (Advanced CNNs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../08_Convolutional_Neural_Networks/index.html#id2">重新训练一个存在架构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../08_Convolutional_Neural_Networks/index.html#stylenet-neural-style">使用Stylenet/Neural-Style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../08_Convolutional_Neural_Networks/index.html#deep-dream">运用Deep Dream</a></li>
</ul>
<p class="caption"><span class="caption-text">递归神经网络(RNN)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_Recurrent_Neural_Networks/index.html">引言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_Recurrent_Neural_Networks/index.html#id2">卷积神经网络模型用于垃圾信息检测</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_Recurrent_Neural_Networks/index.html#lstm">LSTM模型用于文本生成</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_Recurrent_Neural_Networks/index.html#id3">堆叠多层LSTM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_Recurrent_Neural_Networks/index.html#seq2seq">创建段对段模型翻译 (Seq2Seq)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../09_Recurrent_Neural_Networks/index.html#siamese">训练Siamese相似度测量</a></li>
</ul>
<p class="caption"><span class="caption-text">TensorFlow的应用技巧</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../10_Taking_TensorFlow_to_Production/index.html">单元测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../10_Taking_TensorFlow_to_Production/index.html#id2">使用多个执行器 (设备)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../10_Taking_TensorFlow_to_Production/index.html#tensorflow">TensorFlow平行化</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../10_Taking_TensorFlow_to_Production/index.html#id3">TensorFlow开发贴士</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../10_Taking_TensorFlow_to_Production/index.html#id4">TensorFlow开发实例</a></li>
</ul>
<p class="caption"><span class="caption-text">TensorFlow的更多功能</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../11_More_with_TensorFlow/index.html">计算图可视化(用Tensorboard)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11_More_with_TensorFlow/index.html#id1">遗传算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11_More_with_TensorFlow/index.html#k-means">K-means聚类分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11_More_with_TensorFlow/index.html#id2">解决体系常微分方程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11_More_with_TensorFlow/index.html#id3">随机森林</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11_More_with_TensorFlow/index.html#tensorflowkeras">TensorFlow中的Keras</a></li>
</ul>
<p class="caption"><span class="caption-text">TF Cookbook</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html">书籍介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id2">第一章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id3">第二章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id4">第三章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id5">第四章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id6">第五章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id7">第六章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id8">第七章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id9">第八章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id10">第九章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id11">第十章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id12">第十一章</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bookindex.html#id13">索引</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">tensorflow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>tensorflow.python.ops.check_ops</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for tensorflow.python.ops.check_ops</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2016 The TensorFlow Authors. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ==============================================================================</span>
<span class="c1"># pylint: disable=g-short-docstring-punctuation</span>
<span class="sd">&quot;&quot;&quot;Asserts and Boolean Checks.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">collections</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">tensorflow.python.eager</span> <span class="k">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">errors</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">sparse_tensor</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">tensor_shape</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.framework</span> <span class="k">import</span> <span class="n">tensor_util</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="k">import</span> <span class="n">array_ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="k">import</span> <span class="n">control_flow_ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.ops</span> <span class="k">import</span> <span class="n">math_ops</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util</span> <span class="k">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util</span> <span class="k">import</span> <span class="n">deprecation</span>
<span class="kn">from</span> <span class="nn">tensorflow.python.util.tf_export</span> <span class="k">import</span> <span class="n">tf_export</span>

<span class="n">NUMERIC_TYPES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
    <span class="p">[</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
     <span class="n">dtypes</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">qint8</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">qint32</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">quint8</span><span class="p">,</span>
     <span class="n">dtypes</span><span class="o">.</span><span class="n">complex64</span><span class="p">])</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;assert_negative&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_positive&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_proper_iterable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_non_negative&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_non_positive&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_equal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_none_equal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_near&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_integer&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_less&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_less_equal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_greater&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_greater_equal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_rank&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_rank_at_least&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_rank_in&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_same_float_dtype&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_scalar&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_type&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_shapes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_non_decreasing&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_numeric_tensor&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_strictly_increasing&#39;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_maybe_constant_value_string</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
  <span class="n">const_t</span> <span class="o">=</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">constant_value</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">const_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">const_t</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">_assert_static</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Raises a InvalidArgumentError with as much information as possible.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">condition</span><span class="p">:</span>
    <span class="n">data_static</span> <span class="o">=</span> <span class="p">[</span><span class="n">_maybe_constant_value_string</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidArgumentError</span><span class="p">(</span><span class="n">node_def</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">message</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_static</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_shape_and_dtype_str</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a string containing tensor&#39;s shape and dtype.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="s1">&#39;shape=</span><span class="si">%s</span><span class="s1"> dtype=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unary_assert_doc</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Common docstring for assert_* ops that evaluate a unary predicate over every element of a tensor.</span>

<span class="sd">  Args:</span>
<span class="sd">    sym: Mathematical symbol for the check performed on each element, i.e. &quot;&gt; 0&quot;</span>
<span class="sd">    sym_name: English-language name for the op described by sym</span>

<span class="sd">  Returns:</span>
<span class="sd">    Decorator that adds the appropriate docstring to the function for symbol</span>
<span class="sd">    `sym`.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generated decorator that adds the appropriate docstring to the function for symbol `sym`.</span>

<span class="sd">    Args:</span>
<span class="sd">      func: Function for a TensorFlow op</span>

<span class="sd">    Returns:</span>
<span class="sd">      Version of `func` with documentation attached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opname</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">cap_sym_name</span> <span class="o">=</span> <span class="n">sym_name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>

    <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Assert the condition `x </span><span class="si">{sym}</span><span class="s2">` holds element-wise.</span>

<span class="s2">    When running in graph mode, you should add a dependency on this operation</span>
<span class="s2">    to ensure that it runs. Example of adding a dependency to an operation:</span>

<span class="s2">    ```python</span>
<span class="s2">    with tf.control_dependencies([tf.debugging.</span><span class="si">{opname}</span><span class="s2">(x, y)]):</span>
<span class="s2">      output = tf.reduce_sum(x)</span>
<span class="s2">    ```</span>

<span class="s2">    </span><span class="si">{sym_name}</span><span class="s2"> means, for every element `x[i]` of `x`, we have `x[i] </span><span class="si">{sym}</span><span class="s2">`.</span>
<span class="s2">    If `x` is empty this is trivially satisfied.</span>

<span class="s2">    Args:</span>
<span class="s2">      x:  Numeric `Tensor`.</span>
<span class="s2">      data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="s2">        error message and first few entries of `x`.</span>
<span class="s2">      summarize: Print this many entries of each tensor.</span>
<span class="s2">      message: A string to prefix to the default message.</span>
<span class="s2">      name: A name for this operation (optional).  Defaults to &quot;</span><span class="si">{opname}</span><span class="s2">&quot;.</span>

<span class="s2">    Returns:</span>
<span class="s2">      Op that raises `InvalidArgumentError` if `x </span><span class="si">{sym}</span><span class="s2">` is False.</span>
<span class="s2">      @compatibility(eager)</span>
<span class="s2">        returns None</span>
<span class="s2">      @end_compatibility</span>

<span class="s2">    Raises:</span>
<span class="s2">      InvalidArgumentError: if the check can be performed immediately and</span>
<span class="s2">        `x </span><span class="si">{sym}</span><span class="s2">` is False. The check can be performed immediately during </span>
<span class="s2">        eager execution or if `x` is statically known.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">sym</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="n">sym_name</span><span class="o">=</span><span class="n">cap_sym_name</span><span class="p">,</span> <span class="n">opname</span><span class="o">=</span><span class="n">opname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>

  <span class="k">return</span> <span class="n">_decorator</span>


<span class="k">def</span> <span class="nf">_binary_assert_doc</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Common docstring for most of the v1 assert_* ops that compare two tensors element-wise.</span>

<span class="sd">  Args:</span>
<span class="sd">    sym: Binary operation symbol, i.e. &quot;==&quot;</span>

<span class="sd">  Returns:</span>
<span class="sd">    Decorator that adds the appropriate docstring to the function for</span>
<span class="sd">  symbol `sym`.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generated decorator that adds the appropriate docstring to the function for symbol `sym`.</span>

<span class="sd">    Args:</span>
<span class="sd">      func: Function for a TensorFlow op</span>

<span class="sd">    Returns:</span>
<span class="sd">      A version of `func` with documentation attached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opname</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Assert the condition `x </span><span class="si">{sym}</span><span class="s2"> y` holds element-wise.</span>

<span class="s2">    This condition holds if for every pair of (possibly broadcast) elements</span>
<span class="s2">    `x[i]`, `y[i]`, we have `x[i] </span><span class="si">{sym}</span><span class="s2"> y[i]`.</span>
<span class="s2">    If both `x` and `y` are empty, this is trivially satisfied.</span>

<span class="s2">    When running in graph mode, you should add a dependency on this operation</span>
<span class="s2">    to ensure that it runs. Example of adding a dependency to an operation:</span>

<span class="s2">    ```python</span>
<span class="s2">    with tf.control_dependencies([tf.compat.v1.</span><span class="si">{opname}</span><span class="s2">(x, y)]):</span>
<span class="s2">      output = tf.reduce_sum(x)</span>
<span class="s2">    ```</span>

<span class="s2">    Args:</span>
<span class="s2">      x:  Numeric `Tensor`.</span>
<span class="s2">      y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="s2">      data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="s2">        error message and first few entries of `x`, `y`.</span>
<span class="s2">      summarize: Print this many entries of each tensor.</span>
<span class="s2">      message: A string to prefix to the default message.</span>
<span class="s2">      name: A name for this operation (optional).  Defaults to &quot;</span><span class="si">{opname}</span><span class="s2">&quot;.</span>

<span class="s2">    Returns:</span>
<span class="s2">      Op that raises `InvalidArgumentError` if `x </span><span class="si">{sym}</span><span class="s2"> y` is False.</span>
<span class="s2">      @compatibility(eager)</span>
<span class="s2">        returns None</span>
<span class="s2">      @end_compatibility</span>

<span class="s2">    Raises:</span>
<span class="s2">      InvalidArgumentError: if the check can be performed immediately and</span>
<span class="s2">        `x </span><span class="si">{sym}</span><span class="s2"> y` is False. The check can be performed immediately during </span>
<span class="s2">        eager execution or if `x` and `y` are statically known.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">sym</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="n">opname</span><span class="o">=</span><span class="n">opname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>

  <span class="k">return</span> <span class="n">_decorator</span>


<span class="k">def</span> <span class="nf">_make_assert_msg_data</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">test_op</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Subroutine of _binary_assert that generates the components of the default error message when running in eager mode.</span>

<span class="sd">  Args:</span>
<span class="sd">    sym: Mathematical symbol for the test to apply to pairs of tensor elements,</span>
<span class="sd">      i.e. &quot;==&quot;</span>
<span class="sd">    x: First input to the assertion after applying `convert_to_tensor()`</span>
<span class="sd">    y: Second input to the assertion</span>
<span class="sd">    summarize: Value of the &quot;summarize&quot; parameter to the original assert_* call;</span>
<span class="sd">      tells how many elements of each tensor to print.</span>
<span class="sd">    test_op: TensorFlow op that returns a Boolean tensor with True in each</span>
<span class="sd">      position where the assertion is satisfied.</span>

<span class="sd">  Returns:</span>
<span class="sd">    List of tensors and scalars that, when stringified and concatenated,</span>
<span class="sd">    will produce the error message string.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Prepare a message with first elements of x and y.</span>
  <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Condition x </span><span class="si">%s</span><span class="s1"> y did not hold.&#39;</span> <span class="o">%</span> <span class="n">sym</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">summarize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">():</span>
      <span class="c1"># If the shapes of x and y are the same (and not scalars),</span>
      <span class="c1"># Get the values that actually differed and their indices.</span>
      <span class="c1"># If shapes are different this information is more confusing</span>
      <span class="c1"># than useful.</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">test_op</span><span class="p">)</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
      <span class="n">indices_np</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
      <span class="n">x_vals</span> <span class="o">=</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
      <span class="n">y_vals</span> <span class="o">=</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
      <span class="n">num_vals</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">summarize</span><span class="p">,</span> <span class="n">indices_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Indices of first </span><span class="si">%d</span><span class="s1"> different values:&#39;</span> <span class="o">%</span> <span class="n">num_vals</span><span class="p">)</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices_np</span><span class="p">[:</span><span class="n">num_vals</span><span class="p">])</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Corresponding x values:&#39;</span><span class="p">)</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_vals</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))[:</span><span class="n">num_vals</span><span class="p">])</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Corresponding y values:&#39;</span><span class="p">)</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_vals</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))[:</span><span class="n">num_vals</span><span class="p">])</span>

    <span class="c1"># reshape((-1,)) is the fastest way to get a flat array view.</span>
    <span class="n">x_np</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
    <span class="n">y_np</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
    <span class="n">x_sum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_np</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">summarize</span><span class="p">)</span>
    <span class="n">y_sum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_np</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">summarize</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;First </span><span class="si">%d</span><span class="s1"> elements of x:&#39;</span> <span class="o">%</span> <span class="n">x_sum</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_np</span><span class="p">[:</span><span class="n">x_sum</span><span class="p">])</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;First </span><span class="si">%d</span><span class="s1"> elements of y:&#39;</span> <span class="o">%</span> <span class="n">y_sum</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_np</span><span class="p">[:</span><span class="n">y_sum</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_pretty_print</span><span class="p">(</span><span class="n">data_item</span><span class="p">,</span> <span class="n">summarize</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Format a data item for use in an error message in eager mode.</span>

<span class="sd">  Args:</span>
<span class="sd">    data_item: One of the items in the &quot;data&quot; argument to an assert_* function.</span>
<span class="sd">      Can be a Tensor or a scalar value.</span>
<span class="sd">    summarize: How many elements to retain of each tensor-valued entry in data.</span>

<span class="sd">  Returns:</span>
<span class="sd">    An appropriate string representation of data_item</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_item</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">data_item</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
      <span class="c1"># Tensor.numpy() returns a scalar for zero-dimensional tensors</span>
      <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">flat</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
      <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flat</span><span class="p">[:</span><span class="n">summarize</span><span class="p">]]</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">flat</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_item</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_binary_assert</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="n">op_func</span><span class="p">,</span> <span class="n">static_func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span>
                   <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Generic binary elementwise assertion.</span>

<span class="sd">  Implements the behavior described in _binary_assert_doc() above.</span>
<span class="sd">  Args:</span>
<span class="sd">    sym: Mathematical symbol for the test to apply to pairs of tensor elements,</span>
<span class="sd">      i.e. &quot;==&quot;</span>
<span class="sd">    opname: Name of the assert op in the public API, i.e. &quot;assert_equal&quot;</span>
<span class="sd">    op_func: Function that, if passed the two Tensor inputs to the assertion (x</span>
<span class="sd">      and y), will return the test to be passed to reduce_all() i.e.</span>
<span class="sd">    static_func: Function that, if passed numpy ndarray versions of the two</span>
<span class="sd">      inputs to the assertion, will return a Boolean ndarray with containing</span>
<span class="sd">      True in all positions where the assertion PASSES.</span>
<span class="sd">      i.e. np.equal for assert_equal()</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="sd">      error message and first few entries of `x`, `y`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to the value of</span>
<span class="sd">      `opname`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    See docstring template in _binary_assert_doc().</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">test_op</span> <span class="o">=</span> <span class="n">op_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">condition</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">test_op</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
        <span class="k">return</span>

      <span class="c1"># If we get here, the assertion has failed.</span>
      <span class="c1"># Default to printing 3 elements like control_flow_ops.Assert (used</span>
      <span class="c1"># by graph mode) does. Also treat negative values as &quot;print</span>
      <span class="c1"># everything&quot; for consistency with Tensor::SummarizeValue().</span>
      <span class="k">if</span> <span class="n">summarize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">summarize</span> <span class="o">=</span> <span class="mi">3</span>
      <span class="k">elif</span> <span class="n">summarize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">summarize</span> <span class="o">=</span> <span class="mf">1e9</span>  <span class="c1"># Code below will find exact size of x and y.</span>

      <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_make_assert_msg_data</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">test_op</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">message</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

      <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidArgumentError</span><span class="p">(</span>
          <span class="n">node_def</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">op</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">message</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_pretty_print</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">summarize</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)))</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># not context.executing_eagerly()</span>
      <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;Condition x </span><span class="si">%s</span><span class="s1"> y did not hold element-wise:&#39;</span> <span class="o">%</span> <span class="n">sym</span><span class="p">,</span>
            <span class="s1">&#39;x (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
            <span class="s1">&#39;y (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">y</span>
        <span class="p">]</span>
      <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">message</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">condition</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">op_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
      <span class="n">x_static</span> <span class="o">=</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">constant_value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">y_static</span> <span class="o">=</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">constant_value</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">x_static</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y_static</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">condition_static</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">static_func</span><span class="p">(</span><span class="n">x_static</span><span class="p">,</span> <span class="n">y_static</span><span class="p">))</span>
        <span class="n">_assert_static</span><span class="p">(</span><span class="n">condition_static</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span>
    <span class="s1">&#39;debugging.assert_proper_iterable&#39;</span><span class="p">,</span>
    <span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_proper_iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_proper_iterable&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_proper_iterable&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_proper_iterable</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Static assert that values is a &quot;proper&quot; iterable.</span>

<span class="sd">  `Ops` that expect iterables of `Tensor` can call this to validate input.</span>
<span class="sd">  Useful since `Tensor`, `ndarray`, byte/text type are all iterables themselves.</span>

<span class="sd">  Args:</span>
<span class="sd">    values:  Object to be checked.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError:  If `values` is not iterable or is one of</span>
<span class="sd">      `Tensor`, `SparseTensor`, `np.array`, `tf.compat.bytes_or_text_types`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">unintentional_iterables</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">sparse_tensor</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">compat</span><span class="o">.</span><span class="n">bytes_or_text_types</span>
  <span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">unintentional_iterables</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="s1">&#39;Expected argument &quot;values&quot; to be a &quot;proper&quot; iterable.  Found: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
        <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="s1">&#39;Expected argument &quot;values&quot; to be iterable.  Found: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_negative&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_negative_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &lt; 0` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &lt; 0` holds for every element of `x`. If `x` is</span>
<span class="sd">  empty, this is trivially satisfied.</span>

<span class="sd">  If `x` is not negative everywhere, `message`, as well as the first `summarize`</span>
<span class="sd">  entries of `x` are printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_negative&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` is all negative. This can be</span>
<span class="sd">      used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x[i] &lt; 0` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` is statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_negative</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_negative&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_negative&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_negative&#39;</span><span class="p">)</span>
<span class="nd">@_unary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&lt; 0&#39;</span><span class="p">,</span> <span class="s1">&#39;negative&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_negative</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_negative&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span>
          <span class="s1">&#39;Condition x &lt; 0 did not hold element-wise:&#39;</span><span class="p">,</span>
          <span class="s1">&#39;x (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assert_less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_positive&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_positive_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &gt; 0` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &gt; 0` holds for every element of `x`. If `x` is</span>
<span class="sd">  empty, this is trivially satisfied.</span>

<span class="sd">  If `x` is not positive everywhere, `message`, as well as the first `summarize`</span>
<span class="sd">  entries of `x` are printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional). Defaults to &quot;assert_positive&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` is all positive. This can be</span>
<span class="sd">      used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x[i] &gt; 0` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` is statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_positive</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_positive&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_positive&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_positive&#39;</span><span class="p">)</span>
<span class="nd">@_unary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&gt; 0&#39;</span><span class="p">,</span> <span class="s1">&#39;positive&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_positive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_positive&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span> <span class="s1">&#39;Condition x &gt; 0 did not hold element-wise:&#39;</span><span class="p">,</span>
          <span class="s1">&#39;x (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assert_less</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_non_negative&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_non_negative_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &gt;= 0` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &gt;= 0` holds for every element of `x`. If `x` is</span>
<span class="sd">  empty, this is trivially satisfied.</span>

<span class="sd">  If `x` is not &gt;= 0 everywhere, `message`, as well as the first `summarize`</span>
<span class="sd">  entries of `x` are printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to</span>
<span class="sd">      &quot;assert_non_negative&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` is all non-negative. This can</span>
<span class="sd">      be used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x[i] &gt;= 0` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` is statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_non_negative</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
                             <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_non_negative&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_non_negative&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_non_negative&#39;</span><span class="p">)</span>
<span class="nd">@_unary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&gt;= 0&#39;</span><span class="p">,</span> <span class="s1">&#39;non-negative&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_non_negative</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_non_negative&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span>
          <span class="s1">&#39;Condition x &gt;= 0 did not hold element-wise:&#39;</span><span class="p">,</span>
          <span class="s1">&#39;x (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assert_less_equal</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_non_positive&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_non_positive_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &lt;= 0` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &lt;= 0` holds for every element of `x`. If `x` is</span>
<span class="sd">  empty, this is trivially satisfied.</span>

<span class="sd">  If `x` is not &lt;= 0 everywhere, `message`, as well as the first `summarize`</span>
<span class="sd">  entries of `x` are printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to</span>
<span class="sd">      &quot;assert_non_positive&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` is all non-positive. This can</span>
<span class="sd">      be used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x[i] &lt;= 0` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` is statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_non_positive</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
                             <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_non_positive&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_non_positive&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_non_positive&#39;</span><span class="p">)</span>
<span class="nd">@_unary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&lt;= 0&#39;</span><span class="p">,</span> <span class="s1">&#39;non-positive&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_non_positive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_non_positive&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span>
          <span class="s1">&#39;Condition x &lt;= 0 did not hold element-wise:&#39;</span>
          <span class="s1">&#39;x (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assert_less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_equal&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_equal_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x == y` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] == y[i]` holds for every pair of (possibly</span>
<span class="sd">  broadcast) elements of `x` and `y`. If both `x` and `y` are empty, this is</span>
<span class="sd">  trivially satisfied.</span>

<span class="sd">  If `x` and `y` are not equal, `message`, as well as the first `summarize`</span>
<span class="sd">  entries of `x` and `y` are printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_equal&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x == y` is False. This can be</span>
<span class="sd">      used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x == y` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` and `y` are statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_equal</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="assert_equal"><a class="viewcode-back" href="../../../../index.html#tensorflow.assert_equal">[docs]</a><span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_equal&#39;</span><span class="p">])</span>
<span class="nd">@_binary_assert_doc</span><span class="p">(</span><span class="s1">&#39;==&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_equal&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="c1"># Short-circuit if x and y are the same tensor.</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span> <span class="k">else</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">no_op</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">_binary_assert</span><span class="p">(</span><span class="s1">&#39;==&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_equal&#39;</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">equal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                        <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_none_equal&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_none_equal_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x != y` holds for all elements.</span>

<span class="sd">  This Op checks that `x[i] != y[i]` holds for every pair of (possibly</span>
<span class="sd">  broadcast) elements of `x` and `y`. If both `x` and `y` are empty, this is</span>
<span class="sd">  trivially satisfied.</span>

<span class="sd">  If any elements of `x` and `y` are equal, `message`, as well as the first</span>
<span class="sd">  `summarize` entries of `x` and `y` are printed, and `InvalidArgumentError`</span>
<span class="sd">  is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to</span>
<span class="sd">    &quot;assert_none_equal&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x != y` is ever False. This can</span>
<span class="sd">      be used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x != y` is False for any pair of elements in `x` and `y`. The check can</span>
<span class="sd">      be performed immediately during eager execution or if `x` and `y` are</span>
<span class="sd">      statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_none_equal</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
                           <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_none_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_none_equal&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_none_equal&#39;</span><span class="p">)</span>
<span class="nd">@_binary_assert_doc</span><span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_none_equal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_binary_assert</span><span class="p">(</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_none_equal&#39;</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">not_equal</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_near&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_near_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x` and `y` are close element-wise.</span>

<span class="sd">  This Op checks that `x[i] - y[i] &lt; atol + rtol * tf.abs(y[i])` holds for every</span>
<span class="sd">  pair of (possibly broadcast) elements of `x` and `y`. If both `x` and `y` are</span>
<span class="sd">  empty, this is trivially satisfied.</span>

<span class="sd">  If any elements of `x` and `y` are not close, `message`, as well as the first</span>
<span class="sd">  `summarize` entries of `x` and `y` are printed, and `InvalidArgumentError`</span>
<span class="sd">  is raised.</span>

<span class="sd">  The default `atol` and `rtol` is `10 * eps`, where `eps` is the smallest</span>
<span class="sd">  representable positive number such that `1 + eps != 1`.  This is about</span>
<span class="sd">  `1.2e-6` in `32bit`, `2.22e-15` in `64bit`, and `0.00977` in `16bit`.</span>
<span class="sd">  See `numpy.finfo`.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: Float or complex `Tensor`.</span>
<span class="sd">    y: Float or complex `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    rtol:  `Tensor`.  Same `dtype` as, and broadcastable to, `x`.</span>
<span class="sd">      The relative tolerance.  Default is `10 * eps`.</span>
<span class="sd">    atol:  `Tensor`.  Same `dtype` as, and broadcastable to, `x`.</span>
<span class="sd">      The absolute tolerance.  Default is `10 * eps`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_near&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x` and `y` are not close enough.</span>
<span class="sd">      This can be used with `tf.control_dependencies` inside of `tf.function`s</span>
<span class="sd">      to block followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x != y` is False for any pair of elements in `x` and `y`. The check can</span>
<span class="sd">      be performed immediately during eager execution or if `x` and `y` are</span>
<span class="sd">      statically known.</span>

<span class="sd">  @compatibility(numpy)</span>
<span class="sd">  Similar to `numpy.assert_allclose`, except tolerance depends on data type.</span>
<span class="sd">  This is due to the fact that `TensorFlow` is often used with `32bit`, `64bit`,</span>
<span class="sd">  and even `16bit` data.</span>
<span class="sd">  @end_compatibility</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_near</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span>
                     <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_near&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_near&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_near&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_near</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x` and `y` are close element-wise.</span>

<span class="sd">  Example of adding a dependency to an operation:</span>

<span class="sd">  ```python</span>
<span class="sd">  with tf.control_dependencies([tf.compat.v1.assert_near(x, y)]):</span>
<span class="sd">    output = tf.reduce_sum(x)</span>
<span class="sd">  ```</span>

<span class="sd">  This condition holds if for every pair of (possibly broadcast) elements</span>
<span class="sd">  `x[i]`, `y[i]`, we have</span>

<span class="sd">  ```tf.abs(x[i] - y[i]) &lt;= atol + rtol * tf.abs(y[i])```.</span>

<span class="sd">  If both `x` and `y` are empty, this is trivially satisfied.</span>

<span class="sd">  The default `atol` and `rtol` is `10 * eps`, where `eps` is the smallest</span>
<span class="sd">  representable positive number such that `1 + eps != 1`.  This is about</span>
<span class="sd">  `1.2e-6` in `32bit`, `2.22e-15` in `64bit`, and `0.00977` in `16bit`.</span>
<span class="sd">  See `numpy.finfo`.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Float or complex `Tensor`.</span>
<span class="sd">    y:  Float or complex `Tensor`, same `dtype` as, and broadcastable to, `x`.</span>
<span class="sd">    rtol:  `Tensor`.  Same `dtype` as, and broadcastable to, `x`.</span>
<span class="sd">      The relative tolerance.  Default is `10 * eps`.</span>
<span class="sd">    atol:  `Tensor`.  Same `dtype` as, and broadcastable to, `x`.</span>
<span class="sd">      The absolute tolerance.  Default is `10 * eps`.</span>
<span class="sd">    data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="sd">      error message and first few entries of `x`, `y`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_near&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x` and `y` are not close enough.</span>

<span class="sd">  @compatibility(numpy)</span>
<span class="sd">  Similar to `numpy.assert_allclose`, except tolerance depends on data type.</span>
<span class="sd">  This is due to the fact that `TensorFlow` is often used with `32bit`, `64bit`,</span>
<span class="sd">  and even `16bit` data.</span>
<span class="sd">  @end_compatibility</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_near&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">as_numpy_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">eps</span> <span class="k">if</span> <span class="n">rtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rtol</span>
    <span class="n">atol</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">eps</span> <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">atol</span>

    <span class="n">rtol</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rtol&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">atol</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;atol&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">x_name</span> <span class="o">=</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="n">y_name</span> <span class="o">=</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">x_name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
      <span class="n">y_name</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span>
          <span class="s1">&#39;x and y not equal to tolerance rtol = </span><span class="si">%s</span><span class="s1">, atol = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">),</span>
          <span class="s1">&#39;x (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">x_name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y (</span><span class="si">%s</span><span class="s1">) = &#39;</span> <span class="o">%</span> <span class="n">y_name</span><span class="p">,</span> <span class="n">y</span>
      <span class="p">]</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_less&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_less&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_less_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &lt; y` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &lt; y[i]` holds for every pair of (possibly</span>
<span class="sd">  broadcast) elements of `x` and `y`. If both `x` and `y` are empty, this is</span>
<span class="sd">  trivially satisfied.</span>

<span class="sd">  If `x` is not less than `y` element-wise, `message`, as well as the first</span>
<span class="sd">  `summarize` entries of `x` and `y` are printed, and `InvalidArgumentError` is</span>
<span class="sd">  raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_less&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x &lt; y` is False.</span>
<span class="sd">    This can be used with `tf.control_dependencies` inside of `tf.function`s</span>
<span class="sd">    to block followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x &lt; y` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` and `y` are statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_less</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="assert_less"><a class="viewcode-back" href="../../../../index.html#tensorflow.assert_less">[docs]</a><span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_less&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_less&#39;</span><span class="p">])</span>
<span class="nd">@_binary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_binary_assert</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_less&#39;</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">less</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                        <span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_less_equal&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_less_equal_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &lt;= y` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &lt;= y[i]` holds for every pair of (possibly</span>
<span class="sd">  broadcast) elements of `x` and `y`. If both `x` and `y` are empty, this is</span>
<span class="sd">  trivially satisfied.</span>

<span class="sd">  If `x` is not less or equal than `y` element-wise, `message`, as well as the</span>
<span class="sd">  first `summarize` entries of `x` and `y` are printed, and</span>
<span class="sd">  `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional). Defaults to &quot;assert_less_equal&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x &lt;= y` is False. This can be</span>
<span class="sd">      used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x &lt;= y` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` and `y` are statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_less_equal</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                           <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_less_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_less_equal&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_less_equal&#39;</span><span class="p">)</span>
<span class="nd">@_binary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&lt;=&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_binary_assert</span><span class="p">(</span><span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_less_equal&#39;</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">less_equal</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_greater&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_greater&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_greater_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &gt; y` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &gt; y[i]` holds for every pair of (possibly</span>
<span class="sd">  broadcast) elements of `x` and `y`. If both `x` and `y` are empty, this is</span>
<span class="sd">  trivially satisfied.</span>

<span class="sd">  If `x` is not greater than `y` element-wise, `message`, as well as the first</span>
<span class="sd">  `summarize` entries of `x` and `y` are printed, and `InvalidArgumentError` is</span>
<span class="sd">  raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_greater&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x &gt; y` is False. This can be</span>
<span class="sd">      used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x &gt; y` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` and `y` are statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_greater</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="assert_greater"><a class="viewcode-back" href="../../../../index.html#tensorflow.assert_greater">[docs]</a><span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_greater&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_greater&#39;</span><span class="p">])</span>
<span class="nd">@_binary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
  <span class="k">return</span> <span class="n">_binary_assert</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_greater&#39;</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">greater</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                        <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_greater_equal&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_greater_equal_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert the condition `x &gt;= y` holds element-wise.</span>

<span class="sd">  This Op checks that `x[i] &gt;= y[i]` holds for every pair of (possibly</span>
<span class="sd">  broadcast) elements of `x` and `y`. If both `x` and `y` are empty, this is</span>
<span class="sd">  trivially satisfied.</span>

<span class="sd">  If `x` is not greater or equal to `y` element-wise, `message`, as well as the</span>
<span class="sd">  first `summarize` entries of `x` and `y` are printed, and</span>
<span class="sd">  `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    y:  Numeric `Tensor`, same dtype as and broadcastable to `x`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to</span>
<span class="sd">    &quot;assert_greater_equal&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op that raises `InvalidArgumentError` if `x &gt;= y` is False. This can be</span>
<span class="sd">      used with `tf.control_dependencies` inside of `tf.function`s to block</span>
<span class="sd">      followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x &gt;= y` is False. The check can be performed immediately during eager</span>
<span class="sd">      execution or if `x` and `y` are statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_greater_equal</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_greater_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_greater_equal&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_greater_equal&#39;</span><span class="p">)</span>
<span class="nd">@_binary_assert_doc</span><span class="p">(</span><span class="s1">&#39;&gt;=&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">_binary_assert</span><span class="p">(</span><span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_greater_equal&#39;</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_assert_rank_condition</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">static_condition</span><span class="p">,</span> <span class="n">dynamic_condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert `x` has a rank that satisfies a given condition.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    rank:  Scalar `Tensor`.</span>
<span class="sd">    static_condition:   A python function that takes `[actual_rank, given_rank]`</span>
<span class="sd">      and returns `True` if the condition is satisfied, `False` otherwise.</span>
<span class="sd">    dynamic_condition:  An `op` that takes [actual_rank, given_rank] and return</span>
<span class="sd">      `True` if the condition is satisfied, `False` otherwise.</span>
<span class="sd">    data:  The tensors to print out if the condition is false.  Defaults to</span>
<span class="sd">      error message and first few entries of `x`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` if `x` fails dynamic_condition.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine `x` fails static_condition.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">assert_type</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

  <span class="c1"># Attempt to statically defined rank.</span>
  <span class="n">rank_static</span> <span class="o">=</span> <span class="n">tensor_util</span><span class="o">.</span><span class="n">constant_value</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">rank_static</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">rank_static</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Rank must be a scalar.&#39;</span><span class="p">)</span>

    <span class="n">x_rank_static</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">ndims</span>
    <span class="k">if</span> <span class="n">x_rank_static</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">static_condition</span><span class="p">(</span><span class="n">x_rank_static</span><span class="p">,</span> <span class="n">rank_static</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Static rank condition failed&#39;</span><span class="p">,</span> <span class="n">x_rank_static</span><span class="p">,</span> <span class="n">rank_static</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">no_op</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static_checks_determined_all_ok&#39;</span><span class="p">)</span>

  <span class="n">condition</span> <span class="o">=</span> <span class="n">dynamic_condition</span><span class="p">(</span><span class="n">array_ops</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">rank</span><span class="p">)</span>

  <span class="c1"># Add the condition that `rank` must have rank zero.  Prevents the bug where</span>
  <span class="c1"># someone does assert_rank(x, [n]), rather than assert_rank(x, n).</span>
  <span class="k">if</span> <span class="n">rank_static</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">this_data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Rank must be a scalar. Received rank: &#39;</span><span class="p">,</span> <span class="n">rank</span><span class="p">]</span>
    <span class="n">rank_check</span> <span class="o">=</span> <span class="n">assert_rank</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">this_data</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">with_dependencies</span><span class="p">([</span><span class="n">rank_check</span><span class="p">],</span> <span class="n">condition</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_rank&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_rank&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_rank_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert that `x` has rank equal to `rank`.</span>

<span class="sd">  This Op checks that the rank of `x` is equal to `rank`.</span>

<span class="sd">  If `x` has a different rank, `message`, as well as the shape of `x` are</span>
<span class="sd">  printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: `Tensor`.</span>
<span class="sd">    rank: Scalar integer `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional). Defaults to</span>
<span class="sd">      &quot;assert_rank&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` has specified rank.</span>
<span class="sd">    If static checks determine `x` has correct rank, a `no_op` is returned.</span>
<span class="sd">    This can be used with `tf.control_dependencies` inside of `tf.function`s</span>
<span class="sd">    to block followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: if the check can be performed immediately and</span>
<span class="sd">      `x` does not have rank `rank`. The check can be performed immediately</span>
<span class="sd">      during eager execution or if the shape of `x` is statically known.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_rank</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="assert_rank"><a class="viewcode-back" href="../../../../index.html#tensorflow.assert_rank">[docs]</a><span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_rank&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_rank&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">assert_rank</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert `x` has rank equal to `rank`.</span>

<span class="sd">  Example of adding a dependency to an operation:</span>

<span class="sd">  ```python</span>
<span class="sd">  with tf.control_dependencies([tf.compat.v1.assert_rank(x, 2)]):</span>
<span class="sd">    output = tf.reduce_sum(x)</span>
<span class="sd">  ```</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    rank:  Scalar integer `Tensor`.</span>
<span class="sd">    data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="sd">      error message and the shape of `x`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_rank&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` has specified rank.</span>
<span class="sd">    If static checks determine `x` has correct rank, a `no_op` is returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine `x` has wrong rank.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_rank&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span> <span class="ow">or</span> <span class="p">[])):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>

    <span class="n">static_condition</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">actual_rank</span><span class="p">,</span> <span class="n">given_rank</span><span class="p">:</span> <span class="n">actual_rank</span> <span class="o">==</span> <span class="n">given_rank</span>
    <span class="n">dynamic_condition</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">equal</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span>
          <span class="s1">&#39;Tensor </span><span class="si">%s</span><span class="s1"> must have rank&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="s1">&#39;Received shape: &#39;</span><span class="p">,</span>
          <span class="n">array_ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">assert_op</span> <span class="o">=</span> <span class="n">_assert_rank_condition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">static_condition</span><span class="p">,</span>
                                         <span class="n">dynamic_condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Static rank condition failed&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  Tensor </span><span class="si">%s</span><span class="s1"> must have rank </span><span class="si">%d</span><span class="s1">.  Received rank </span><span class="si">%d</span><span class="s1">, shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">return</span> <span class="n">assert_op</span></div>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_rank_at_least&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_rank_at_least_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert that `x` has rank of at least `rank`.</span>

<span class="sd">  This Op checks that the rank of `x` is greater or equal to `rank`.</span>

<span class="sd">  If `x` has a rank lower than `rank`, `message`, as well as the shape of `x`</span>
<span class="sd">  are printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: `Tensor`.</span>
<span class="sd">    rank: Scalar integer `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to</span>
<span class="sd">      &quot;assert_rank_at_least&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` has specified rank or higher.</span>
<span class="sd">    If static checks determine `x` has correct rank, a `no_op` is returned.</span>
<span class="sd">    This can be used with `tf.control_dependencies` inside of `tf.function`s</span>
<span class="sd">    to block followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: `x` does not have rank at least `rank`, but the rank</span>
<span class="sd">      cannot be statically determined.</span>
<span class="sd">    ValueError: If static checks determine `x` has mismatched rank.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_rank_at_least</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_rank_at_least&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_rank_at_least&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_rank_at_least&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_rank_at_least</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert `x` has rank equal to `rank` or higher.</span>

<span class="sd">  Example of adding a dependency to an operation:</span>

<span class="sd">  ```python</span>
<span class="sd">  with tf.control_dependencies([tf.compat.v1.assert_rank_at_least(x, 2)]):</span>
<span class="sd">    output = tf.reduce_sum(x)</span>
<span class="sd">  ```</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    rank:  Scalar `Tensor`.</span>
<span class="sd">    data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="sd">      error message and first few entries of `x`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).</span>
<span class="sd">      Defaults to &quot;assert_rank_at_least&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless `x` has specified rank or higher.</span>
<span class="sd">    If static checks determine `x` has correct rank, a `no_op` is returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine `x` has wrong rank.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span>
      <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_rank_at_least&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span> <span class="ow">or</span> <span class="p">[])):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>

    <span class="n">static_condition</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">actual_rank</span><span class="p">,</span> <span class="n">given_rank</span><span class="p">:</span> <span class="n">actual_rank</span> <span class="o">&gt;=</span> <span class="n">given_rank</span>
    <span class="n">dynamic_condition</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">greater_equal</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span>
          <span class="s1">&#39;Tensor </span><span class="si">%s</span><span class="s1"> must have rank at least&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
          <span class="s1">&#39;Received shape: &#39;</span><span class="p">,</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">assert_op</span> <span class="o">=</span> <span class="n">_assert_rank_condition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">static_condition</span><span class="p">,</span>
                                         <span class="n">dynamic_condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Static rank condition failed&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  Tensor </span><span class="si">%s</span><span class="s1"> must have rank at least </span><span class="si">%d</span><span class="s1">.  Received rank </span><span class="si">%d</span><span class="s1">, &#39;</span>
            <span class="s1">&#39;shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">return</span> <span class="n">assert_op</span>


<span class="k">def</span> <span class="nf">_static_rank_in</span><span class="p">(</span><span class="n">actual_rank</span><span class="p">,</span> <span class="n">given_ranks</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">actual_rank</span> <span class="ow">in</span> <span class="n">given_ranks</span>


<span class="k">def</span> <span class="nf">_dynamic_rank_in</span><span class="p">(</span><span class="n">actual_rank</span><span class="p">,</span> <span class="n">given_ranks</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">given_ranks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">given_ranks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">actual_rank</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">given_rank</span> <span class="ow">in</span> <span class="n">given_ranks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">given_rank</span><span class="p">,</span> <span class="n">actual_rank</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_assert_ranks_condition</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">static_condition</span><span class="p">,</span> <span class="n">dynamic_condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert `x` has a rank that satisfies a given condition.</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    ranks:  Scalar `Tensor`.</span>
<span class="sd">    static_condition:   A python function that takes</span>
<span class="sd">      `[actual_rank, given_ranks]` and returns `True` if the condition is</span>
<span class="sd">      satisfied, `False` otherwise.</span>
<span class="sd">    dynamic_condition:  An `op` that takes [actual_rank, given_ranks]</span>
<span class="sd">      and return `True` if the condition is satisfied, `False` otherwise.</span>
<span class="sd">    data:  The tensors to print out if the condition is false.  Defaults to</span>
<span class="sd">      error message and first few entries of `x`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` if `x` fails dynamic_condition.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine `x` fails static_condition.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">ranks</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

  <span class="c1"># Attempt to statically defined rank.</span>
  <span class="n">ranks_static</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">tensor_util</span><span class="o">.</span><span class="n">constant_value</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span> <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">ranks</span><span class="p">])</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranks_static</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">rank_static</span> <span class="ow">in</span> <span class="n">ranks_static</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">rank_static</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Rank must be a scalar.&#39;</span><span class="p">)</span>

    <span class="n">x_rank_static</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">ndims</span>
    <span class="k">if</span> <span class="n">x_rank_static</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">static_condition</span><span class="p">(</span><span class="n">x_rank_static</span><span class="p">,</span> <span class="n">ranks_static</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Static rank condition failed&#39;</span><span class="p">,</span> <span class="n">x_rank_static</span><span class="p">,</span> <span class="n">ranks_static</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">no_op</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;static_checks_determined_all_ok&#39;</span><span class="p">)</span>

  <span class="n">condition</span> <span class="o">=</span> <span class="n">dynamic_condition</span><span class="p">(</span><span class="n">array_ops</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ranks</span><span class="p">)</span>

  <span class="c1"># Add the condition that `rank` must have rank zero.  Prevents the bug where</span>
  <span class="c1"># someone does assert_rank(x, [n]), rather than assert_rank(x, n).</span>
  <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">rank_static</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">ranks_static</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rank_static</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">this_data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Rank must be a scalar. Received rank: &#39;</span><span class="p">,</span> <span class="n">rank</span><span class="p">]</span>
      <span class="n">rank_check</span> <span class="o">=</span> <span class="n">assert_rank</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">this_data</span><span class="p">)</span>
      <span class="n">condition</span> <span class="o">=</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">with_dependencies</span><span class="p">([</span><span class="n">rank_check</span><span class="p">],</span> <span class="n">condition</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_rank_in&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_rank_in_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert that `x` has a rank in `ranks`.</span>

<span class="sd">  This Op checks that the rank of `x` is in `ranks`.</span>

<span class="sd">  If `x` has a different rank, `message`, as well as the shape of `x` are</span>
<span class="sd">  printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: `Tensor`.</span>
<span class="sd">    ranks: `Iterable` of scalar `Tensor` objects.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional). Defaults to &quot;assert_rank_in&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless rank of `x` is in `ranks`.</span>
<span class="sd">    If static checks determine `x` has matching rank, a `no_op` is returned.</span>
<span class="sd">    This can be used with `tf.control_dependencies` inside of `tf.function`s</span>
<span class="sd">    to block followup computation until the check has executed.</span>
<span class="sd">    @compatibility(eager)</span>
<span class="sd">    returns None</span>
<span class="sd">    @end_compatibility</span>

<span class="sd">  Raises:</span>
<span class="sd">    InvalidArgumentError: `x` does not have rank in `ranks`, but the rank cannot</span>
<span class="sd">      be statically determined.</span>
<span class="sd">    ValueError: If static checks determine `x` has mismatched rank.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">assert_rank_in</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ranks</span><span class="o">=</span><span class="n">ranks</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_rank_in&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_rank_in&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_rank_in&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_rank_in</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert `x` has rank in `ranks`.</span>

<span class="sd">  Example of adding a dependency to an operation:</span>

<span class="sd">  ```python</span>
<span class="sd">  with tf.control_dependencies([tf.compat.v1.assert_rank_in(x, (2, 4))]):</span>
<span class="sd">    output = tf.reduce_sum(x)</span>
<span class="sd">  ```</span>

<span class="sd">  Args:</span>
<span class="sd">    x:  Numeric `Tensor`.</span>
<span class="sd">    ranks:  Iterable of scalar `Tensor` objects.</span>
<span class="sd">    data:  The tensors to print out if the condition is False.  Defaults to</span>
<span class="sd">      error message and first few entries of `x`.</span>
<span class="sd">    summarize: Print this many entries of each tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).</span>
<span class="sd">      Defaults to &quot;assert_rank_in&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless rank of `x` is in `ranks`.</span>
<span class="sd">    If static checks determine `x` has matching rank, a `no_op` is returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine `x` has mismatched rank.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span>
      <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_rank_in&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span> <span class="ow">or</span> <span class="p">[])):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">ranks</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">ranks</span><span class="p">])</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
          <span class="n">message</span><span class="p">,</span> <span class="s1">&#39;Tensor </span><span class="si">%s</span><span class="s1"> must have rank in&#39;</span> <span class="o">%</span> <span class="n">name</span>
      <span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span>
          <span class="s1">&#39;Received shape: &#39;</span><span class="p">,</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">assert_op</span> <span class="o">=</span> <span class="n">_assert_ranks_condition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">_static_rank_in</span><span class="p">,</span>
                                          <span class="n">_dynamic_rank_in</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Static rank condition failed&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  Tensor </span><span class="si">%s</span><span class="s1"> must have rank in </span><span class="si">%s</span><span class="s1">.  Received rank </span><span class="si">%d</span><span class="s1">, &#39;</span>
            <span class="s1">&#39;shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">return</span> <span class="n">assert_op</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_integer&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_integer_v2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert that `x` is of integer dtype.</span>

<span class="sd">  If `x` has a non-integer type, `message`, as well as the dtype of `x` are</span>
<span class="sd">  printed, and `InvalidArgumentError` is raised.</span>

<span class="sd">  This can always be checked statically, so this method returns nothing.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: A `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional). Defaults to &quot;assert_integer&quot;.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError:  If `x.dtype` is not a non-quantized integer type.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">assert_integer</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_integer&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_integer&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_integer&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_integer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert that `x` is of integer dtype.</span>

<span class="sd">  Example of adding a dependency to an operation:</span>

<span class="sd">  ```python</span>
<span class="sd">  with tf.control_dependencies([tf.compat.v1.assert_integer(x)]):</span>
<span class="sd">    output = tf.reduce_sum(x)</span>
<span class="sd">  ```</span>

<span class="sd">  Args:</span>
<span class="sd">    x: `Tensor` whose basetype is integer and is not quantized.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_integer&quot;.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError:  If `x.dtype` is anything other than non-quantized integer.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A `no_op` that does nothing.  Type can be determined statically.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_integer&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">]):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tensor&#39;</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>
      <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
          <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">  Expected &quot;x&quot; to be integer type.  Found: </span><span class="si">%s</span><span class="s1"> of dtype </span><span class="si">%s</span><span class="s1">&#39;</span>
          <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">no_op</span><span class="p">(</span><span class="s1">&#39;statically_determined_was_integer&#39;</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_type&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_type_v2</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">tf_type</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Asserts that the given `Tensor` is of the specified type.</span>

<span class="sd">  This can always be checked statically, so this method returns nothing.</span>

<span class="sd">  Args:</span>
<span class="sd">    tensor: A `Tensor`.</span>
<span class="sd">    tf_type: A tensorflow type (`dtypes.float32`, `tf.int64`, `dtypes.bool`,</span>
<span class="sd">      etc).</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name:  A name for this operation. Defaults to &quot;assert_type&quot;</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError: If the tensor&#39;s data type doesn&#39;t match `tf_type`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">assert_type</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">tensor</span><span class="p">,</span> <span class="n">tf_type</span><span class="o">=</span><span class="n">tf_type</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_type&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_type&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_type&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_type</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">tf_type</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Statically asserts that the given `Tensor` is of the specified type.</span>

<span class="sd">  Args:</span>
<span class="sd">    tensor: A `Tensor`.</span>
<span class="sd">    tf_type: A tensorflow type (`dtypes.float32`, `tf.int64`, `dtypes.bool`,</span>
<span class="sd">      etc).</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name:  A name to give this `Op`.  Defaults to &quot;assert_type&quot;</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError: If the tensors data type doesn&#39;t match `tf_type`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A `no_op` that does nothing.  Type can be determined statically.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_type&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">tensor</span><span class="p">]):</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tensor&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">tf_type</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> tensor must be of type </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">tf_type</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">  </span><span class="si">%s</span><span class="s1"> must be of type </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                       <span class="n">tf_type</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">no_op</span><span class="p">(</span><span class="s1">&#39;statically_determined_correct_type&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dimension_sizes</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Gets the dimension sizes of a tensor `x`.</span>

<span class="sd">  If a size can be determined statically it is returned as an integer,</span>
<span class="sd">  otherwise as a tensor.</span>

<span class="sd">  If `x` is a scalar it is treated as rank 1 size 1.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: A `Tensor`.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Dimension sizes.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">dynamic_shape</span> <span class="o">=</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">rank</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">rank</span>
  <span class="n">rank_is_known</span> <span class="o">=</span> <span class="n">rank</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="n">rank_is_known</span> <span class="ow">and</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">rank_is_known</span> <span class="ow">and</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">static_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dynamic_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">static_shape</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">sizes</span>
  <span class="n">has_rank_zero</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">array_ops</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
      <span class="n">has_rank_zero</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">constant</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">dynamic_shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_symbolic_dimension_sizes</span><span class="p">(</span><span class="n">symbolic_shape</span><span class="p">):</span>
  <span class="c1"># If len(symbolic_shape) == 0 construct a tuple</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic_shape</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">symbolic_shape</span>


<span class="k">def</span> <span class="nf">_has_known_value</span><span class="p">(</span><span class="n">dimension_size</span><span class="p">):</span>
  <span class="n">not_none</span> <span class="o">=</span> <span class="n">dimension_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="nb">int</span><span class="p">(</span><span class="n">dimension_size</span><span class="p">)</span>
    <span class="n">can_be_parsed_as_int</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
    <span class="n">can_be_parsed_as_int</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="n">not_none</span> <span class="ow">and</span> <span class="n">can_be_parsed_as_int</span>


<span class="k">def</span> <span class="nf">_is_symbol_for_any_size</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">]</span>


<span class="n">_TensorDimSizes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>
    <span class="s1">&#39;_TensorDimSizes&#39;</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;unspecified_dim&#39;</span><span class="p">,</span> <span class="s1">&#39;actual_sizes&#39;</span><span class="p">,</span> <span class="s1">&#39;symbolic_sizes&#39;</span><span class="p">])</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_shapes&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_shapes_v2</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert tensor shapes and dimension size relationships between tensors.</span>

<span class="sd">  This Op checks that a collection of tensors shape relationships</span>
<span class="sd">  satisfies given constraints.</span>

<span class="sd">  Example:</span>

<span class="sd">  &gt;&gt;&gt; n = 10</span>
<span class="sd">  &gt;&gt;&gt; q = 3</span>
<span class="sd">  &gt;&gt;&gt; d = 7</span>
<span class="sd">  &gt;&gt;&gt; x = tf.zeros([n,q]) </span>
<span class="sd">  &gt;&gt;&gt; y = tf.ones([n,d])</span>
<span class="sd">  &gt;&gt;&gt; param = tf.Variable([1.0, 2.0, 3.0])</span>
<span class="sd">  &gt;&gt;&gt; scalar = 1.0</span>
<span class="sd">  &gt;&gt;&gt; tf.debugging.assert_shapes([</span>
<span class="sd">  ...  (x, (&#39;N&#39;, &#39;Q&#39;)),</span>
<span class="sd">  ...  (y, (&#39;N&#39;, &#39;D&#39;)),</span>
<span class="sd">  ...  (param, (&#39;Q&#39;,)),</span>
<span class="sd">  ...  (scalar, ()),</span>
<span class="sd">  ... ])</span>
<span class="sd">  </span>
<span class="sd">  &gt;&gt;&gt; tf.debugging.assert_shapes([</span>
<span class="sd">  ...   (x, (&#39;N&#39;, &#39;D&#39;)), </span>
<span class="sd">  ...   (y, (&#39;N&#39;, &#39;D&#39;))</span>
<span class="sd">  ... ])</span>
<span class="sd">  Traceback (most recent call last):</span>
<span class="sd">  ...</span>
<span class="sd">  ValueError: ...</span>

<span class="sd">  If `x`, `y`, `param` or `scalar` does not have a shape that satisfies</span>
<span class="sd">  all specified constraints, `message`, as well as the first `summarize` entries</span>
<span class="sd">  of the first encountered violating tensor are printed, and</span>
<span class="sd">  `InvalidArgumentError` is raised.</span>

<span class="sd">  Size entries in the specified shapes are checked against other entries by</span>
<span class="sd">  their __hash__, except:</span>
<span class="sd">    - a size entry is interpreted as an explicit size if it can be parsed as an</span>
<span class="sd">      integer primitive.</span>
<span class="sd">    - a size entry is interpreted as *any* size if it is None or &#39;.&#39;.</span>

<span class="sd">  If the first entry of a shape is `...` (type `Ellipsis`) or &#39;*&#39; that indicates</span>
<span class="sd">  a variable number of outer dimensions of unspecified size, i.e. the constraint</span>
<span class="sd">  applies to the inner-most dimensions only.</span>

<span class="sd">  Scalar tensors and specified shapes of length zero (excluding the &#39;inner-most&#39;</span>
<span class="sd">  prefix) are both treated as having a single dimension of size one.</span>

<span class="sd">  Args:</span>
<span class="sd">    shapes: dictionary with (`Tensor` to shape) items. A shape must be an</span>
<span class="sd">      iterable.</span>
<span class="sd">    data: The tensors to print out if the condition is False.  Defaults to error</span>
<span class="sd">      message and first few entries of the violating tensor.</span>
<span class="sd">    summarize: Print this many entries of the tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_shapes&quot;.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine any shape constraint is violated.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">assert_shapes</span><span class="p">(</span>
      <span class="n">shapes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_shapes&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">assert_shapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Assert tensor shapes and dimension size relationships between tensors.</span>

<span class="sd">  This Op checks that a collection of tensors shape relationships</span>
<span class="sd">  satisfies given constraints.</span>

<span class="sd">  Example:</span>

<span class="sd">  ```python</span>
<span class="sd">  tf.assert_shapes([</span>
<span class="sd">    (x, (&#39;N&#39;, &#39;Q&#39;)),</span>
<span class="sd">    (y, (&#39;N&#39;, &#39;D&#39;)),</span>
<span class="sd">    (param, (&#39;Q&#39;,)),</span>
<span class="sd">    (scalar, ())</span>
<span class="sd">  ])</span>
<span class="sd">  ```</span>

<span class="sd">  Example of adding a dependency to an operation:</span>

<span class="sd">  ```python</span>
<span class="sd">  with tf.control_dependencies([tf.assert_shapes(shapes)]):</span>
<span class="sd">    output = tf.matmul(x, y, transpose_a=True)</span>
<span class="sd">  ```</span>

<span class="sd">  If `x`, `y`, `param` or `scalar` does not have a shape that satisfies</span>
<span class="sd">  all specified constraints, `message`, as well as the first `summarize` entries</span>
<span class="sd">  of the first encountered violating tensor are printed, and</span>
<span class="sd">  `InvalidArgumentError` is raised.</span>

<span class="sd">  Size entries in the specified shapes are checked against other entries by</span>
<span class="sd">  their __hash__, except:</span>
<span class="sd">    - a size entry is interpreted as an explicit size if it can be parsed as an</span>
<span class="sd">      integer primitive.</span>
<span class="sd">    - a size entry is interpreted as *any* size if it is None or &#39;.&#39;.</span>

<span class="sd">  If the first entry of a shape is `...` (type `Ellipsis`) or &#39;*&#39; that indicates</span>
<span class="sd">  a variable number of outer dimensions of unspecified size, i.e. the constraint</span>
<span class="sd">  applies to the inner-most dimensions only.</span>

<span class="sd">  Scalar tensors and specified shapes of length zero (excluding the &#39;inner-most&#39;</span>
<span class="sd">  prefix) are both treated as having a single dimension of size one.</span>

<span class="sd">  Args:</span>
<span class="sd">    shapes: dictionary with (`Tensor` to shape) items. A shape must be an</span>
<span class="sd">      iterable.</span>
<span class="sd">    data: The tensors to print out if the condition is False.  Defaults to error</span>
<span class="sd">      message and first few entries of the violating tensor.</span>
<span class="sd">    summarize: Print this many entries of the tensor.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;assert_shapes&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Op raising `InvalidArgumentError` unless all shape constraints are</span>
<span class="sd">    satisfied.</span>
<span class="sd">    If static checks determine all constraints are satisfied, a `no_op` is</span>
<span class="sd">    returned.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError:  If static checks determine any shape constraint is violated.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># If the user manages to assemble a dict containing tensors (possible in</span>
  <span class="c1"># Graph mode only), make sure we still accept that.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

  <span class="n">message</span> <span class="o">=</span> <span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_shapes&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">shapes</span><span class="p">,</span> <span class="n">data</span><span class="p">]):</span>
    <span class="c1"># Shape specified as None implies no constraint</span>
    <span class="n">shape_constraints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shapes</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">]</span>

    <span class="n">executing_eagerly</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tensor_name</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">executing_eagerly</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_shape_and_dtype_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span>

    <span class="n">tensor_dim_sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">symbolic_shape</span> <span class="ow">in</span> <span class="n">shape_constraints</span><span class="p">:</span>
      <span class="n">is_iterable</span> <span class="o">=</span> <span class="p">(</span>
          <span class="nb">hasattr</span><span class="p">(</span><span class="n">symbolic_shape</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="ow">or</span>
          <span class="nb">hasattr</span><span class="p">(</span><span class="n">symbolic_shape</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">)</span>  <span class="c1"># For Python 2 compat.</span>
      <span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">is_iterable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  &#39;</span>
            <span class="s1">&#39;Tensor </span><span class="si">%s</span><span class="s1">.  Specified shape must be an iterable.  &#39;</span>
            <span class="s1">&#39;An iterable has the attribute `__iter__` or `__getitem__`.  &#39;</span>
            <span class="s1">&#39;Received specified shape: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">tensor_name</span><span class="p">(</span><span class="n">tensor</span><span class="p">),</span> <span class="n">symbolic_shape</span><span class="p">))</span>

      <span class="c1"># We convert this into a tuple to handle strings, lists and numpy arrays</span>
      <span class="n">symbolic_shape_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">symbolic_shape</span><span class="p">)</span>

      <span class="n">tensors_specified_innermost</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbolic_shape_tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">]:</span>
          <span class="k">continue</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
              <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  &#39;</span>
              <span class="s1">&#39;Tensor </span><span class="si">%s</span><span class="s1"> specified shape index </span><span class="si">%d</span><span class="s1">.  &#39;</span>
              <span class="s1">&#39;Symbol `...` or `*` for a variable number of &#39;</span>
              <span class="s1">&#39;unspecified dimensions is only allowed as the first entry&#39;</span> <span class="o">%</span>
              <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">tensor_name</span><span class="p">(</span><span class="n">tensor</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>

        <span class="n">tensors_specified_innermost</span> <span class="o">=</span> <span class="kc">True</span>

      <span class="c1"># Only include the size of the specified dimensions since the 0th symbol</span>
      <span class="c1"># is either ellipsis or *</span>
      <span class="n">tensor_dim_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
          <span class="n">_TensorDimSizes</span><span class="p">(</span>
              <span class="n">tensor</span><span class="p">,</span> <span class="n">tensors_specified_innermost</span><span class="p">,</span> <span class="n">_dimension_sizes</span><span class="p">(</span><span class="n">tensor</span><span class="p">),</span>
              <span class="n">_symbolic_dimension_sizes</span><span class="p">(</span>
                  <span class="n">symbolic_shape_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                  <span class="k">if</span> <span class="n">tensors_specified_innermost</span> <span class="k">else</span> <span class="n">symbolic_shape_tuple</span><span class="p">)))</span>

    <span class="n">rank_assertions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sizes</span> <span class="ow">in</span> <span class="n">tensor_dim_sizes</span><span class="p">:</span>
      <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">symbolic_sizes</span><span class="p">)</span>
      <span class="n">rank_zero_or_one</span> <span class="o">=</span> <span class="n">rank</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">sizes</span><span class="o">.</span><span class="n">unspecified_dim</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rank_zero_or_one</span><span class="p">:</span>
          <span class="c1"># No assertion of rank needed as `x` only need to have rank at least</span>
          <span class="c1"># 0. See elif rank_zero_or_one case comment.</span>
          <span class="k">continue</span>
        <span class="n">assertion</span> <span class="o">=</span> <span class="n">assert_rank_at_least</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">rank_zero_or_one</span><span class="p">:</span>
        <span class="c1"># Rank 0 is treated as rank 1 size 1, i.e. there is</span>
        <span class="c1"># no distinction between the two in terms of rank.</span>
        <span class="c1"># See _dimension_sizes.</span>
        <span class="n">assertion</span> <span class="o">=</span> <span class="n">assert_rank_in</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="n">ranks</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">assertion</span> <span class="o">=</span> <span class="n">assert_rank</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
      <span class="n">rank_assertions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assertion</span><span class="p">)</span>

    <span class="n">size_assertions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">size_specifications</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">sizes</span> <span class="ow">in</span> <span class="n">tensor_dim_sizes</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">size_symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">symbolic_sizes</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">_is_symbol_for_any_size</span><span class="p">(</span><span class="n">size_symbol</span><span class="p">):</span>
          <span class="c1"># Size specified as any implies no constraint</span>
          <span class="k">continue</span>

        <span class="k">if</span> <span class="n">sizes</span><span class="o">.</span><span class="n">unspecified_dim</span><span class="p">:</span>
          <span class="n">tensor_dim</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">symbolic_sizes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">tensor_dim</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">size_symbol</span> <span class="ow">in</span> <span class="n">size_specifications</span> <span class="ow">or</span> <span class="n">_has_known_value</span><span class="p">(</span><span class="n">size_symbol</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">_has_known_value</span><span class="p">(</span><span class="n">size_symbol</span><span class="p">):</span>
            <span class="n">specified_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_symbol</span><span class="p">)</span>
            <span class="n">size_check_message</span> <span class="o">=</span> <span class="s1">&#39;Specified explicitly&#39;</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">specified_size</span><span class="p">,</span> <span class="n">specified_by_y</span><span class="p">,</span> <span class="n">specified_at_dim</span> <span class="o">=</span> \
                <span class="n">size_specifications</span><span class="p">[</span><span class="n">size_symbol</span><span class="p">]</span>
            <span class="n">size_check_message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Specified by tensor </span><span class="si">%s</span><span class="s1"> dimension </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">tensor_name</span><span class="p">(</span><span class="n">specified_by_y</span><span class="p">),</span> <span class="n">specified_at_dim</span><span class="p">))</span>

          <span class="n">actual_size</span> <span class="o">=</span> <span class="n">sizes</span><span class="o">.</span><span class="n">actual_sizes</span><span class="p">[</span><span class="n">tensor_dim</span><span class="p">]</span>
          <span class="k">if</span> <span class="n">_has_known_value</span><span class="p">(</span><span class="n">actual_size</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_has_known_value</span><span class="p">(</span><span class="n">specified_size</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">actual_size</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">specified_size</span><span class="p">):</span>
              <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                  <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.  </span><span class="si">%s</span><span class="s1">.  Tensor </span><span class="si">%s</span><span class="s1"> dimension </span><span class="si">%s</span><span class="s1"> must have size </span><span class="si">%d</span><span class="s1">.  &#39;</span>
                  <span class="s1">&#39;Received size </span><span class="si">%d</span><span class="s1">, shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">size_check_message</span><span class="p">,</span> <span class="n">tensor_name</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                   <span class="n">tensor_dim</span><span class="p">,</span> <span class="n">specified_size</span><span class="p">,</span> <span class="n">actual_size</span><span class="p">,</span>
                   <span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()))</span>
            <span class="c1"># No dynamic assertion needed</span>
            <span class="k">continue</span>

          <span class="n">condition</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span>
              <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">actual_size</span><span class="p">),</span>
              <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">specified_size</span><span class="p">))</span>
          <span class="n">data_</span> <span class="o">=</span> <span class="n">data</span>
          <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">message</span><span class="p">,</span> <span class="n">size_check_message</span><span class="p">,</span>
                <span class="s1">&#39;Tensor </span><span class="si">%s</span><span class="s1"> dimension&#39;</span> <span class="o">%</span> <span class="n">tensor_name</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">tensor_dim</span><span class="p">,</span>
                <span class="s1">&#39;must have size&#39;</span><span class="p">,</span> <span class="n">specified_size</span><span class="p">,</span> <span class="s1">&#39;Received shape: &#39;</span><span class="p">,</span>
                <span class="n">array_ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="p">]</span>
          <span class="n">size_assertions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
              <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">summarize</span><span class="o">=</span><span class="n">summarize</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">size</span> <span class="o">=</span> <span class="n">sizes</span><span class="o">.</span><span class="n">actual_sizes</span><span class="p">[</span><span class="n">tensor_dim</span><span class="p">]</span>
          <span class="n">size_specifications</span><span class="p">[</span><span class="n">size_symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">sizes</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tensor_dim</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">control_dependencies</span><span class="p">(</span><span class="n">rank_assertions</span><span class="p">):</span>
      <span class="n">shapes_assertion</span> <span class="o">=</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">size_assertions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shapes_assertion</span>


<span class="c1"># pylint: disable=line-too-long</span>
<span class="k">def</span> <span class="nf">_get_diff_for_monotonic_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Gets the difference x[1:] - x[:-1].&quot;&quot;&quot;</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">is_numeric_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected x to be numeric, instead found: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>

  <span class="c1"># If x has less than 2 elements, there is nothing to compare.  So return [].</span>
  <span class="n">is_shorter_than_two</span> <span class="o">=</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">array_ops</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
  <span class="n">short_result</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

  <span class="c1"># With 2 or more elements, return x[1:] - x[:-1]</span>
  <span class="n">s_len</span> <span class="o">=</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="n">diff</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">strided_slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_len</span><span class="p">)</span><span class="o">-</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">strided_slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s_len</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">control_flow_ops</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">is_shorter_than_two</span><span class="p">,</span> <span class="n">short_result</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span>
    <span class="s1">&#39;debugging.is_numeric_tensor&#39;</span><span class="p">,</span>
    <span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.is_numeric_tensor&#39;</span><span class="p">,</span> <span class="s1">&#39;is_numeric_tensor&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;is_numeric_tensor&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_numeric_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns `True` if the elements of `tensor` are numbers.</span>

<span class="sd">  Specifically, returns `True` if the dtype of `tensor` is one of the following:</span>

<span class="sd">  * `tf.float32`</span>
<span class="sd">  * `tf.float64`</span>
<span class="sd">  * `tf.int8`</span>
<span class="sd">  * `tf.int16`</span>
<span class="sd">  * `tf.int32`</span>
<span class="sd">  * `tf.int64`</span>
<span class="sd">  * `tf.uint8`</span>
<span class="sd">  * `tf.qint8`</span>
<span class="sd">  * `tf.qint32`</span>
<span class="sd">  * `tf.quint8`</span>
<span class="sd">  * `tf.complex64`</span>

<span class="sd">  Returns `False` if `tensor` is of a non-numeric type or if `tensor` is not</span>
<span class="sd">  a `tf.Tensor` object.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">NUMERIC_TYPES</span>


<span class="nd">@tf_export</span><span class="p">(</span>
    <span class="s1">&#39;math.is_non_decreasing&#39;</span><span class="p">,</span>
    <span class="n">v1</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;math.is_non_decreasing&#39;</span><span class="p">,</span> <span class="s1">&#39;debugging.is_non_decreasing&#39;</span><span class="p">,</span>
        <span class="s1">&#39;is_non_decreasing&#39;</span>
    <span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;debugging.is_non_decreasing&#39;</span><span class="p">,</span>
                                  <span class="s1">&#39;is_non_decreasing&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_non_decreasing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns `True` if `x` is non-decreasing.</span>

<span class="sd">  Elements of `x` are compared in row-major order.  The tensor `[x[0],...]`</span>
<span class="sd">  is non-decreasing if for every adjacent pair we have `x[i] &lt;= x[i+1]`.</span>
<span class="sd">  If `x` has less than two elements, it is trivially non-decreasing.</span>

<span class="sd">  See also:  `is_strictly_increasing`</span>

<span class="sd">  &gt;&gt;&gt; x1 = tf.constant([1.0, 1.0, 3.0])</span>
<span class="sd">  &gt;&gt;&gt; tf.math.is_non_decreasing(x1)</span>
<span class="sd">  &lt;tf.Tensor: shape=(), dtype=bool, numpy=True&gt;</span>
<span class="sd">  &gt;&gt;&gt; x2 = tf.constant([3.0, 1.0, 2.0])</span>
<span class="sd">  &gt;&gt;&gt; tf.math.is_non_decreasing(x2)</span>
<span class="sd">  &lt;tf.Tensor: shape=(), dtype=bool, numpy=False&gt;</span>

<span class="sd">  Args:</span>
<span class="sd">    x: Numeric `Tensor`.</span>
<span class="sd">    name: A name for this operation (optional).  Defaults to &quot;is_non_decreasing&quot;</span>

<span class="sd">  Returns:</span>
<span class="sd">    Boolean `Tensor`, equal to `True` iff `x` is non-decreasing.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError: if `x` is not a numeric tensor.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;is_non_decreasing&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">]):</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">_get_diff_for_monotonic_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># When len(x) = 1, diff = [], less_equal = [], and reduce_all([]) = True.</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">diff</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">diff</span><span class="p">))</span>


<span class="nd">@tf_export</span><span class="p">(</span>
    <span class="s1">&#39;math.is_strictly_increasing&#39;</span><span class="p">,</span>
    <span class="n">v1</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;math.is_strictly_increasing&#39;</span><span class="p">,</span> <span class="s1">&#39;debugging.is_strictly_increasing&#39;</span><span class="p">,</span>
        <span class="s1">&#39;is_strictly_increasing&#39;</span>
    <span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;debugging.is_strictly_increasing&#39;</span><span class="p">,</span>
                                  <span class="s1">&#39;is_strictly_increasing&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_strictly_increasing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns `True` if `x` is strictly increasing.</span>

<span class="sd">  Elements of `x` are compared in row-major order.  The tensor `[x[0],...]`</span>
<span class="sd">  is strictly increasing if for every adjacent pair we have `x[i] &lt; x[i+1]`.</span>
<span class="sd">  If `x` has less than two elements, it is trivially strictly increasing.</span>

<span class="sd">  See also:  `is_non_decreasing`</span>

<span class="sd">  &gt;&gt;&gt; x1 = tf.constant([1.0, 2.0, 3.0])</span>
<span class="sd">  &gt;&gt;&gt; tf.math.is_strictly_increasing(x1)</span>
<span class="sd">  &lt;tf.Tensor: shape=(), dtype=bool, numpy=True&gt;</span>
<span class="sd">  &gt;&gt;&gt; x2 = tf.constant([3.0, 1.0, 2.0])</span>
<span class="sd">  &gt;&gt;&gt; tf.math.is_strictly_increasing(x2)</span>
<span class="sd">  &lt;tf.Tensor: shape=(), dtype=bool, numpy=False&gt;</span>

<span class="sd">  Args:</span>
<span class="sd">    x: Numeric `Tensor`.</span>
<span class="sd">    name: A name for this operation (optional).</span>
<span class="sd">      Defaults to &quot;is_strictly_increasing&quot;</span>

<span class="sd">  Returns:</span>
<span class="sd">    Boolean `Tensor`, equal to `True` iff `x` is strictly increasing.</span>

<span class="sd">  Raises:</span>
<span class="sd">    TypeError: if `x` is not a numeric tensor.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;is_strictly_increasing&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">]):</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">_get_diff_for_monotonic_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># When len(x) = 1, diff = [], less = [], and reduce_all([]) = True.</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">diff</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math_ops</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">diff</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_assert_same_base_type</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">expected_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Asserts all items are of the same base type.</span>

<span class="sd">  Args:</span>
<span class="sd">    items: List of graph items (e.g., `Variable`, `Tensor`, `SparseTensor`,</span>
<span class="sd">        `Operation`, or `IndexedSlices`). Can include `None` elements, which</span>
<span class="sd">        will be ignored.</span>
<span class="sd">    expected_type: Expected type. If not specified, assert all items are</span>
<span class="sd">        of the same base type.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Validated type, or none if neither expected_type nor items provided.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError: If any types do not match.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">original_expected_type</span> <span class="o">=</span> <span class="n">expected_type</span>
  <span class="n">mismatch</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">item_type</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base_dtype</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">expected_type</span><span class="p">:</span>
        <span class="n">expected_type</span> <span class="o">=</span> <span class="n">item_type</span>
      <span class="k">elif</span> <span class="n">expected_type</span> <span class="o">!=</span> <span class="n">item_type</span><span class="p">:</span>
        <span class="n">mismatch</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">break</span>
  <span class="k">if</span> <span class="n">mismatch</span><span class="p">:</span>
    <span class="c1"># Loop back through and build up an informative error message (this is very</span>
    <span class="c1"># slow, so we don&#39;t do it unless we found an error above).</span>
    <span class="n">expected_type</span> <span class="o">=</span> <span class="n">original_expected_type</span>
    <span class="n">original_item_str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">item_type</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">base_dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expected_type</span><span class="p">:</span>
          <span class="n">expected_type</span> <span class="o">=</span> <span class="n">item_type</span>
          <span class="n">original_item_str</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expected_type</span> <span class="o">!=</span> <span class="n">item_type</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, type=</span><span class="si">%s</span><span class="s1">, must be of the same type (</span><span class="si">%s</span><span class="s1">)</span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
              <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
              <span class="n">item_type</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">,</span>
              <span class="p">(</span><span class="s1">&#39; as </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">original_item_str</span><span class="p">)</span> <span class="k">if</span> <span class="n">original_item_str</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">expected_type</span>  <span class="c1"># Should be unreachable</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">expected_type</span>


<span class="nd">@tf_export</span><span class="p">(</span>
    <span class="s1">&#39;debugging.assert_same_float_dtype&#39;</span><span class="p">,</span>
    <span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_same_float_dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_same_float_dtype&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_same_float_dtype&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_same_float_dtype</span><span class="p">(</span><span class="n">tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Validate and return float type based on `tensors` and `dtype`.</span>

<span class="sd">  For ops such as matrix multiplication, inputs and weights must be of the</span>
<span class="sd">  same float type. This function validates that all `tensors` are the same type,</span>
<span class="sd">  validates that type is `dtype` (if supplied), and returns the type. Type must</span>
<span class="sd">  be a floating point type. If neither `tensors` nor `dtype` is supplied,</span>
<span class="sd">  the function will return `dtypes.float32`.</span>

<span class="sd">  Args:</span>
<span class="sd">    tensors: Tensors of input values. Can include `None` elements, which will be</span>
<span class="sd">        ignored.</span>
<span class="sd">    dtype: Expected type.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Validated type.</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError: if neither `tensors` nor `dtype` is supplied, or result is not</span>
<span class="sd">        float, or the common type of the inputs is not a floating point type.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">tensors</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_assert_same_base_type</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float32</span>
  <span class="k">elif</span> <span class="ow">not</span> <span class="n">dtype</span><span class="o">.</span><span class="n">is_floating</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected floating point type, got </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dtype</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;debugging.assert_scalar&#39;</span><span class="p">,</span> <span class="n">v1</span><span class="o">=</span><span class="p">[])</span>
<span class="k">def</span> <span class="nf">assert_scalar_v2</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Asserts that the given `tensor` is a scalar.</span>

<span class="sd">  This function raises `ValueError` unless it can be certain that the given</span>
<span class="sd">  `tensor` is a scalar. `ValueError` is also raised if the shape of `tensor` is</span>
<span class="sd">  unknown.</span>

<span class="sd">  This is always checked statically, so this method returns nothing.</span>

<span class="sd">  Args:</span>
<span class="sd">    tensor: A `Tensor`.</span>
<span class="sd">    message: A string to prefix to the default message.</span>
<span class="sd">    name:  A name for this operation. Defaults to &quot;assert_scalar&quot;</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError: If the tensor is not scalar (rank 0), or if its shape is</span>
<span class="sd">      unknown.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">assert_scalar</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">tensor</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="nd">@tf_export</span><span class="p">(</span><span class="n">v1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debugging.assert_scalar&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_scalar&#39;</span><span class="p">])</span>
<span class="nd">@deprecation</span><span class="o">.</span><span class="n">deprecated_endpoints</span><span class="p">(</span><span class="s1">&#39;assert_scalar&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">assert_scalar</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Asserts that the given `tensor` is a scalar (i.e. zero-dimensional).</span>

<span class="sd">  This function raises `ValueError` unless it can be certain that the given</span>
<span class="sd">  `tensor` is a scalar. `ValueError` is also raised if the shape of `tensor` is</span>
<span class="sd">  unknown.</span>

<span class="sd">  Args:</span>
<span class="sd">    tensor: A `Tensor`.</span>
<span class="sd">    name:  A name for this operation. Defaults to &quot;assert_scalar&quot;</span>
<span class="sd">    message: A string to prefix to the default message.</span>

<span class="sd">  Returns:</span>
<span class="sd">    The input tensor (potentially converted to a `Tensor`).</span>

<span class="sd">  Raises:</span>
<span class="sd">    ValueError: If the tensor is not scalar (rank 0), or if its shape is</span>
<span class="sd">      unknown.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">with</span> <span class="n">ops</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;assert_scalar&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">tensor</span><span class="p">])</span> <span class="k">as</span> <span class="n">name_scope</span><span class="p">:</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name_scope</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">ndims</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">Expected scalar shape, saw shape: </span><span class="si">%s</span><span class="s1">.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="p">,))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">Expected scalar shape for </span><span class="si">%s</span><span class="s1">, saw shape: </span><span class="si">%s</span><span class="s1">.&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">message</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tensor</span>


<div class="viewcode-block" id="ensure_shape"><a class="viewcode-back" href="../../../../index.html#tensorflow.ensure_shape">[docs]</a><span class="nd">@tf_export</span><span class="p">(</span><span class="s1">&#39;ensure_shape&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ensure_shape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Updates the shape of a tensor and checks at runtime that the shape holds.</span>

<span class="sd">  For example:</span>
<span class="sd">  ```python</span>
<span class="sd">  x = tf.compat.v1.placeholder(tf.int32)</span>
<span class="sd">  print(x.shape)</span>
<span class="sd">  ==&gt; TensorShape(None)</span>
<span class="sd">  y = x * 2</span>
<span class="sd">  print(y.shape)</span>
<span class="sd">  ==&gt; TensorShape(None)</span>

<span class="sd">  y = tf.ensure_shape(y, (None, 3, 3))</span>
<span class="sd">  print(y.shape)</span>
<span class="sd">  ==&gt; TensorShape([Dimension(None), Dimension(3), Dimension(3)])</span>

<span class="sd">  with tf.compat.v1.Session() as sess:</span>
<span class="sd">    # Raises tf.errors.InvalidArgumentError, because the shape (3,) is not</span>
<span class="sd">    # compatible with the shape (None, 3, 3)</span>
<span class="sd">    sess.run(y, feed_dict={x: [1, 2, 3]})</span>

<span class="sd">  ```</span>

<span class="sd">  NOTE: This differs from `Tensor.set_shape` in that it sets the static shape</span>
<span class="sd">  of the resulting tensor and enforces it at runtime, raising an error if the</span>
<span class="sd">  tensor&#39;s runtime shape is incompatible with the specified shape.</span>
<span class="sd">  `Tensor.set_shape` sets the static shape of the tensor without enforcing it</span>
<span class="sd">  at runtime, which may result in inconsistencies between the statically-known</span>
<span class="sd">  shape of tensors and the runtime value of tensors.</span>

<span class="sd">  Args:</span>
<span class="sd">    x: A `Tensor`.</span>
<span class="sd">    shape: A `TensorShape` representing the shape of this tensor, a</span>
<span class="sd">      `TensorShapeProto`, a list, a tuple, or None.</span>
<span class="sd">    name: A name for this operation (optional). Defaults to &quot;EnsureShape&quot;.</span>

<span class="sd">  Returns:</span>
<span class="sd">    A `Tensor`. Has the same type and contents as `x`. At runtime, raises a</span>
<span class="sd">    `tf.errors.InvalidArgumentError` if `shape` is incompatible with the shape</span>
<span class="sd">    of `x`.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">tensor_shape</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">):</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">tensor_shape</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">array_ops</span><span class="o">.</span><span class="n">ensure_shape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<span class="nd">@ops</span><span class="o">.</span><span class="n">RegisterGradient</span><span class="p">(</span><span class="s1">&#39;EnsureShape&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_ensure_shape_grad</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
  <span class="k">del</span> <span class="n">op</span>  <span class="c1"># Unused.</span>
  <span class="k">return</span> <span class="n">grad</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright - Wei MEI (Nick Cafferry).

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>